{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ADIF MCP","text":"<p>ADIF MCP is a set of Model Context Protocol tools that give AI agents safe, typed access to Amateur Radio logging data using the ADIF standard.</p>"},{"location":"#core-project-health","title":"Core Project Health","text":""},{"location":"#project-ethos","title":"Project Ethos","text":"<p>ADIF-MCP is a community-driven effort. It is not intended to replace or compete with existing ADIF libraries, utilities, or logging applications. Instead, it provides a common foundation that others can build upon.</p> <ul> <li>Interoperability \u2014 a schema-driven, spec-compliant core that makes it easier for tools, logs, and services to talk to each other.</li> <li>Extensibility \u2014 a plugin and integration framework for services like LoTW, eQSL, QRZ, and future platforms.</li> <li>Collaboration \u2014 designed to complement, not fragment, the ecosystem of ADIF tools already enjoyed by the ham community.</li> <li>Future-facing \u2014 introduces safe, typed access to ADIF data in contexts such as AI agents and MCP integrations, opening doors for innovation while preserving compatibility.</li> </ul> <p>Our goal is simple: support and enhance the Amateur Radio logging ecosystem while keeping the project open, transparent, and aligned with the spirit of the hobby.</p>"},{"location":"#why-adif-mcp","title":"Why ADIF MCP?","text":"<ul> <li>Safe, schema-validated access to log data</li> <li>Full ADIF 3.1.5 compatibility (upward-compatible with future ADIF)</li> <li>Extensible plugin system (LoTW, eQSL, \u2026)</li> <li>Designed for AI agents and modern developer workflows</li> </ul>"},{"location":"#what-this-project-provides","title":"What This Project Provides","text":"<ul> <li>Core: ADIF parsing, validation, canonical types, and tool contracts</li> <li>Plugins: LoTW and eQSL integrations as separate MCPs</li> <li>Goals: portability, safety, testability, and vendor-neutral interfaces</li> </ul> <p>\ud83d\udc49 Start with the User Guide or setup to setup and contrubite code, see the Dev Guide.</p>"},{"location":"program-id-policy/","title":"Program ID &amp; APP_ Field Policy","text":"<p>The ADIF-MCP project uses registered ADIF Program IDs to clearly identify log exports and transformations. This ensures transparency, auditability, and compatibility with other ADIF-compliant applications.</p>"},{"location":"program-id-policy/#1-registered-program-ids","title":"1. Registered Program IDs","text":"<ul> <li><code>ADIF-MCP</code> \u2014 the core engine (https://github.com/KI7MT/adif-mcp)</li> <li><code>ADIF-MCP-LOTW</code> \u2014 plugin for ARRL Logbook of The World (LoTW) (https://github.com/KI7MT/adif-mcp-lotw)</li> <li><code>ADIF-MCP-EQSL</code> \u2014 plugin for eQSL.cc (https://github.com/KI7MT/adif-mcp-eqsl)</li> </ul> <p>Each plugin or engine component reports <code>PROGRAMVERSION</code> equal to its package release version.</p>"},{"location":"program-id-policy/#2-app_-vendor-extensions","title":"2. APP_ Vendor Extensions","text":"<p>To avoid overwriting a user\u2019s original <code>PROGRAMID</code>, ADIF-MCP components may add APP_ fields with namespaced provenance. Examples:</p> <ul> <li><code>APP_ADIF-MCP_OP</code> \u2014 operation performed (e.g., <code>normalize</code>, <code>validate</code>, <code>merge</code>)</li> <li><code>APP_ADIF-MCP-LOTW_ACTION</code> \u2014 LoTW operation (<code>upload</code>, <code>fetch</code>, <code>merge</code>)</li> <li><code>APP_ADIF-MCP-EQSL_TIME</code> \u2014 UTC timestamp of eQSL confirmation merge</li> <li><code>APP_ADIF-MCP_SESSION</code> \u2014 batch/session UUID for audit trail</li> <li><code>APP_ADIF-MCP_MANIFEST</code> \u2014 MCP manifest/tool version that executed the action</li> </ul> <p>These fields are optional but recommended when the engine or plugins modify or confirm records.</p>"},{"location":"program-id-policy/#3-policy-summary","title":"3. Policy Summary","text":"<ul> <li>Exports from core: set <code>PROGRAMID=ADIF-MCP</code></li> <li>Exports from plugins: set <code>PROGRAMID=ADIF-MCP-LOTW</code> or <code>ADIF-MCP-EQSL</code></li> <li>Augmenting existing logs: preserve original <code>PROGRAMID</code> and add <code>APP_</code> provenance fields</li> </ul> <p>All ADIF files produced are upward-compatible with the ADIF 3.1.5 specification and future revisions.</p>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#completed-up-through-v034","title":"Completed (up through v0.3.4)","text":""},{"location":"roadmap/#core-packaging-structure","title":"Core packaging &amp; structure","text":"<ul> <li>src/adif_mcp/ canonical layout</li> <li>identity/ namespace (models, store, secrets, manager, errors)</li> <li>Resources bundled under resources/ (spec, schemas, providers, mapping/usage)</li> <li>Manifests moved into src/adif_mcp/mcp/manifest.json</li> </ul>"},{"location":"roadmap/#provider-probes","title":"Provider probes","text":"<ul> <li>provider index-check (no network)</li> <li>provider probe (GET-only, safe, redacting secrets)</li> <li>CI/make targets: probe-index, probe-get, probe-all</li> </ul>"},{"location":"roadmap/#quality-gates","title":"Quality gates","text":"<ul> <li>ruff, mypy --strict, interrogate integrated with pre-commit</li> <li>CI workflows fixed for uv + pre-commit + manifest validation</li> <li>All checks green in CI/CD</li> </ul>"},{"location":"roadmap/#docs","title":"Docs","text":"<ul> <li>Developer setup for Linux/macOS \u2705</li> <li>Command reference (incl. make help merged) \u2705</li> <li>Persona management documented (stub + keyring) \u2705</li> <li>Roadmap and dev plan unified \u2705</li> </ul>"},{"location":"roadmap/#releases","title":"Releases","text":"<ul> <li>v0.3.0 \u2192 v0.3.4, all tagged, CHANGELOG updated</li> </ul> <p>\u2e3b</p>"},{"location":"roadmap/#in-progress-next-milestone-v035-v040","title":"In Progress / Next Milestone (v0.3.5 \u2192 v0.4.0)","text":""},{"location":"roadmap/#demo-tools-eqsl","title":"Demo tools (eQSL)","text":"<ul> <li>eqsl.fetch_inbox \u2192 mock + real mode (still stubbed)</li> <li>eqsl.filter_summary \u2192 analytics (band/mode/date/confirmed)</li> </ul>"},{"location":"roadmap/#validation-normalization","title":"Validation / normalization","text":"<ul> <li>Expand models.py into proper ADIF Pydantic models</li> <li>Add normalize.py helpers (callsign, grid, dates, times, rst, freq, power)</li> <li>Add enums/ JSON + loader (bands, modes, qsl flags)</li> </ul>"},{"location":"roadmap/#cli","title":"CLI","text":"<ul> <li>Align naming: validate-manifest pattern</li> <li>Move dev/test stubs under adif-mcp dev \u2026 group</li> </ul>"},{"location":"roadmap/#docs_1","title":"Docs","text":"<ul> <li>Integrations pages: start with eQSL quickstart</li> <li>Add \u201cuseful code snippets\u201d section (bash helpers, persona reset, etc.)</li> <li>CI smoke doc (how probes run in CI without network)</li> </ul>"},{"location":"roadmap/#ci","title":"CI","text":"<ul> <li>Add make probe-index smoke to CI (non-network)</li> <li>Ensure manifest validation runs once (not duplicated across jobs)</li> </ul> <p>\u2e3b</p>"},{"location":"roadmap/#near-term-roadmap-whats-left-before-calling-040","title":"Near-Term Roadmap (what\u2019s left before calling 0.4.0)","text":"<ol> <li>Finish eQSL demo tools (real + mock).</li> <li>Normalize ADIF models (basic fields).</li> <li>Expose enums + validation tools (list_enums, validate_adif).</li> <li>Docs polish (CLI help dumps, quickstarts, troubleshooting).</li> <li>Refactor stubs into dev/ CLI group.</li> </ol>"},{"location":"concepts/adif-basics/","title":"ADIF Basics","text":"<ul> <li>Records: QSO fields (CALL, BAND, MODE, QSO_DATE, TIME_ON, etc.)</li> <li>Types: string, number, date/time; plus enumerations per spec</li> <li>Validation: ensure fields exist, are typed, and conform to spec</li> </ul>"},{"location":"concepts/choice-of-llms/","title":"Choice of LLMs","text":"<p>One of the first questions operators ask is: \u201cHow much is this going to cost me?\u201d</p> <p>The answer: it\u2019s entirely up to you.</p> <p>ADIF-MCP doesn\u2019t ship with, or require, a specific Large Language Model (LLM). Instead, it provides a standard interface so you (or developers) can connect whatever model fits your needs, budget, and shack setup:</p> <ul> <li>Free / Local Models</li> <li>Run open-source LLMs (like LLaMA-3, Mistral, or Mixtral) on your own PC, NUC, or server.</li> <li>Tools like Ollama make this easy to run offline, with zero cloud cost.</li> <li> <p>Great for experimenters, DIYers, or anyone who prefers not to rely on the internet.</p> </li> <li> <p>Commercial Cloud Models</p> </li> <li>Use providers like OpenAI (ChatGPT), Anthropic (Claude), or Google (Gemini).</li> <li>These are \u201cplug and play\u201d with powerful reasoning and large context windows.</li> <li> <p>Costs vary, but many have free tiers and low-cost options for light use.</p> </li> <li> <p>Hybrid Setups</p> </li> <li>Some operators may use a small free local model for day-to-day queries,     and keep a stronger paid model in reserve for heavy lifting (e.g., log analysis or award prep).</li> </ul>"},{"location":"concepts/choice-of-llms/#in-short","title":"In short","text":"<ul> <li>Operators can choose free local if cost is the priority.</li> <li>Developers can choose best-in-class paid models if capability is the priority.</li> <li>Everyone gets the same MCP backbone \u2014 the choice of LLM is up to you.</li> </ul> <p>Just like antennas or radios, there\u2019s no one \u201cright\u201d answer: your shack, your choice.</p>"},{"location":"concepts/why-matters/","title":"Why ADIF-MCP Matters","text":"<p>Many operators just want quick answers regarding their logs:</p> <ul> <li>\u201cDid I work that station on 30m last month?\u201d</li> <li>\u201cWhich QSOs are still unconfirmed on LoTW?\u201d</li> <li>\"Am I in the Log for X.Y.Z Dxepdition\"</li> </ul> <p>Traditionally, getting those answers means exporting ADIF, writing scripts, logging into one or more sites. That is a barrier \u2014 especially if you don\u2019t code, or you're not sitting in front of your shack computer.</p> <p></p>"},{"location":"concepts/why-matters/#how-adif-mcp-helps","title":"How ADIF-MCP helps","text":"<ul> <li>Backbone \u2014 Spec-compliant, schema-driven access to ADIF data.</li> <li>Agents \u2014 Chat/voice tools ask natural-language questions over your logs.</li> <li>Integrations \u2014 Connect to LoTW, eQSL, QRZ, Club Log (and more) in a typed, safe way.</li> </ul> <p>In short: ADIF-MCP handles the plumbing; agents handle the conversation.</p>"},{"location":"concepts/why-matters/#why-it-matters","title":"Why it matters","text":"<ul> <li>Lower friction: insights without scripting.</li> <li>Future-proof: typed access for AI agents &amp; MCP integrations.</li> <li>Ecosystem-friendly: complements (not replaces) existing loggers and services.</li> <li>Flexible: useful for casual operators and award chasers alike.</li> </ul>"},{"location":"concepts/why-matters/#examples","title":"Examples","text":"<ul> <li>Awards: Summarize LoTW/eQSL confirmations for DXCC/WAS/30MDG.</li> <li>Portable ops: \u201cWhich of my SOTA/POTA activations are confirmed?\u201d</li> <li>Contest: Filter/summarize contest QSOs without custom code.</li> </ul> <p>ADIF-MCP isn\u2019t a logger replacement \u2014 it\u2019s a common foundation so operators, developers, and agents can work with ADIF data more easily and safely.</p>"},{"location":"dev/code-snippets/","title":"Code Snippets &amp; Helpers","text":"<p>Code snippets handy for rendering commonly used items quickly. While this is a subjective topic on how one sets up their environment, these we have found helpful. For linux anmd Mac users, add them to your <code>.bashrc</code>, <code>.bash_profile</code> or create <code>.bash_functions</code> and <code>.bash_aliases</code> and sounce them how you wish. For windows users, we'll get the Poweshell commands done when time allows.</p>"},{"location":"dev/code-snippets/#1-print-available-providers","title":"1. Print available providers","text":"<pre><code>uv run python -c \"from adif_mcp.resources import list_providers; print(list_providers())\"\n\n# Load ADIF meta version\nuv run python -c \"from adif_mcp.resources import get_adif_meta; print(get_adif_meta()['spec_version'])\"\n</code></pre>"},{"location":"dev/code-snippets/#2-simple-quick-actoin-functions","title":"2. Simple Quick Actoin Functions","text":"<pre><code># List what personas you have configured\npersona-list() {\n  uv run adif-mcp persona list --verbose\n}\n\n# Add a contest persona with dates\npersona-add-contest() {\n  uv run adif-mcp persona add \\\n    --name \"ContestW7A\" \\\n    --callsign W7A \\\n    --start 2025-03-01 \\\n    --end   2025-03-03\n}\n\n# Validate manifest (short alias)\nmanifest-check() {\n  uv run adif-mcp validate-manifest\n}\n</code></pre>"},{"location":"dev/code-snippets/#2-recreate-your-persona-mappings","title":"2. Recreate Your Persona Mappings","text":"<p>This example is for my own scallsign history. I have one callsign change that was merged into my primary eQSL and LoTW logbooks. You can add as many as needed.</p> <p>Important Overlap Note - when chaing call signs, either via vanity call, or licenense upgrades, stop the old call one day short of the new call start date. That avoids any potential collisions with dates when making queries. Also note, this applies to your Primary Lincese callsign, but could also apply to club calls.</p> <p>Important Security Note - There are no credentials leaked here. Export your Password as ENV variables for the current session. The fucntion will pick them up for entry. You should never ( as a standrd security practice, never write down or save passowrds in files ; use exported ENV variables as they ephemerial )</p> <p>Real Example - The Example below is how I re-create my personans. KI7MT is my primary callsign. KE1HA was my previous call. Both call signs are merged in LoTW and eQSL for award purposes.The personas I used are for the major logging platforms: <code>MyEQSL</code>, <code>MyLOTW</code>, <code>MyQRZ</code>, <code>MyCLUBLOG</code>. The associated usernames and passwored are stored in macOS Keychain with <code>set-credentials</code>, For things like contests, or special events, use an event handle, for example: <code>CQ-WW-CW-2025-W7X</code> or whatever makes sense as the identifier.</p> <pre><code>#\n# Each of these expects you to have exported the relevant secrets to environment variables beforehand\n#\n#   export EQSL_USER=... EQSL_PASS=...\n#   export LOTW_USER=... LOTW_PASS=...\n#   export QRZ_USER=...  QRZ_KEY=...\n#   export CLUBLOG_USER=... CLUBLOG_KEY=...\n#\nfunction reset-personas () {\n  set -euo pipefail\n\n# Clear all the existing adif-mcp personas and secrets\nuv run adif-mcp persona remove-all --yes || true\n\n# Add KI7MT personas starting 2009-12-22\nuv run adif-mcp persona add --name MyEQSL    --callsign KI7MT --start 2009-12-22\nuv run adif-mcp persona add --name MyLOTW    --callsign KI7MT --start 2009-12-22\nuv run adif-mcp persona add --name MyQRZ     --callsign KI7MT --start 2009-12-22\nuv run adif-mcp persona add --name MyCLUBLOG --callsign KI7MT --start 2009-12-22\n\n# add login credentials and save to macOS Keychain for safe keeping\n# WinCred for Windows\n# systemd-secrets or vault for linux\nuv run adif-mcp persona set-credential --persona MyEQSL    --provider eqsl    --username \"${EQSL_USER}\"    --password \"${EQSL_PASS}\"\nuv run adif-mcp persona set-credential --persona MyLOTW    --provider lotw    --username \"${LOTW_USER}\"    --password \"${LOTW_PASS}\"\nuv run adif-mcp persona set-credential --persona MyQRZ     --provider qrz     --username \"${QRZ_USER}\"     --password \"${QRZ_KEY}\"\nuv run adif-mcp persona set-credential --persona MyCLUBLOG --provider clublog --username \"${CLUBLOG_USER}\" --password \"${CLUBLOG_KEY}\"\n\n# Add my previous call sign as a persona, using my Primay account ( KI7MT ) for login\n# Again, KE1HA is merged in LoTW and eQSL. If yours is not, add the appropriate user and password for those accounts.\nuv run adif-mcp persona add --name KE1HA --callsign KE1HA --start 2001-04-16 --end 2009-12-21\nuv run adif-mcp persona set-credential --persona KE1HA --provider eqsl     --username \"${EQSL_USER}\"    --password \"${EQSL_PASS}\"\nuv run adif-mcp persona set-credential --persona KE1HA --provider lotw     --username \"${LOTW_USER}\"    --password \"${LOTW_PASS}\"\nuv run adif-mcp persona set-credential --persona KE1HA --provider qrz      --username \"${QRZ_USER}\"     --password \"${QRZ_KEY}\"\nuv run adif-mcp persona set-credential --persona KE1HA --provider clublog  --username \"${CLUBLOG_USER}\" --password \"${CLUBLOG_KEY}\"\n\n# Print out my list of personans in verbose mode\nuv run adif-mcp persona list --verbose\n}\n</code></pre>"},{"location":"dev/command-reference/","title":"Useful Command Reference (Dev &amp; Power Users)","text":"<p>A compact, copy-pasteable guide to the most common commands you\u2019ll use while developing or validating adif-mcp.</p>"},{"location":"dev/command-reference/#1-quick-start","title":"1. Quick Start","text":"<pre><code># Install deps (project venv managed by uv)\nuv sync\n\n# See CLI help\nuv run adif-mcp --help\nuv run adif-mcp version\n</code></pre>"},{"location":"dev/command-reference/#2-environments","title":"2. Environments","text":"<pre><code># Show which Python uv is using and where the venv lives\nuv run python -c \"import sys,site;print(sys.executable);print(site.getsitepackages())\"\n\n# Recreate venv from lock\nuv sync --frozen\n</code></pre>"},{"location":"dev/command-reference/#3-code-quality-local-parity-with-ci","title":"3. Code Quality (local parity with CI)","text":"<pre><code># Lint (Ruff)\nuv run ruff check .\nuv run ruff check . --fix\nuv run ruff format .\n\n# Type check (mypy)\nuv run mypy src\n\n# Docstring coverage (interrogate)\nuv run interrogate -c pyproject.toml\nuv run interrogate -vv -c pyproject.toml --fail-under=100 src test\n</code></pre>"},{"location":"dev/command-reference/#4-one-shot-gates-make","title":"4. One-shot gates (Make)","text":"<pre><code># Local smoke (quick) and full gate (CI parity)\nmake smoke-all\nmake gate\n</code></pre>"},{"location":"dev/command-reference/#5-tests","title":"5. Tests","text":"<pre><code># All tests\nuv run pytest -q\n\n# Specific file or test\nuv run pytest -q test/test_resources.py\nuv run pytest -q -k \"manifest\"\n</code></pre>"},{"location":"dev/command-reference/#6-provider-probes-get-sanity-checks","title":"6. Provider Probes (GET sanity checks)","text":"<pre><code># Index (no network): checks persona + provider wiring\nuv run adif-mcp provider index-check --provider lotw   --persona MyLOTW\nuv run adif-mcp provider index-check --provider eqsl   --persona MyEQSL\nuv run adif-mcp provider index-check --provider qrz    --persona MyQRZ\nuv run adif-mcp provider index-check --provider clublog --persona MyCLUBLOG\n\n# Network GET (safe probe)\nuv run adif-mcp provider probe --provider lotw   --persona MyLOTW    --timeout 30\nuv run adif-mcp provider probe --provider eqsl   --persona MyEQSL    --timeout 30\nuv run adif-mcp provider probe --provider qrz    --persona MyQRZ     --timeout 30\nuv run adif-mcp provider probe --provider clublog --persona MyCLUBLOG --timeout 30\n\n# Make helpers\nmake probe-index\nmake probe-get\nmake probe-all\n</code></pre>"},{"location":"dev/command-reference/#7-personas-credentials","title":"7. Personas &amp; Credentials","text":"<pre><code># List / show\nuv run adif-mcp persona list\nuv run adif-mcp persona show Primary\nuv run adif-mcp persona show --by callsign KI7MT\n\n# Add / update\nuv run adif-mcp persona add --name Primary --callsign KI7MT\nuv run adif-mcp persona add --name ContestW7A --callsign W7A --start 2025-03-01 --end 2025-03-31\n\n# Set credential ( stores ref in index; secret in OS keyring )\nuv run adif-mcp persona set-credential --persona Primary --provider lotw --username ki7mt\n\n# Remove one / all\nuv run adif-mcp persona remove Primary\nuv run adif-mcp persona remove-all --yes\n</code></pre>"},{"location":"dev/command-reference/#8-manifest-validation","title":"8. Manifest Validation","text":"<pre><code># Preferred (packaged manifest with repo fallback)\nuv run adif-mcp validate-manifest\n\n# Make target (calls the CLI)\nmake validate-manifest\n</code></pre>"},{"location":"dev/command-reference/#9-building-installing-locally","title":"9. Building &amp; Installing Locally","text":"<pre><code># Build sdist+wheel\nuv build\n\n# Install the just-built wheel in a throwaway venv to smoke test packaging\npython -m venv /tmp/adif-smoke &amp;&amp; source /tmp/adif-smoke/bin/activate\npip install ./dist/adif_mcp-*.whl\nadif-mcp --help\ndeactivate\n</code></pre>"},{"location":"dev/command-reference/#10-common-troubleshooting","title":"10. Common Troubleshooting","text":"<pre><code># Clear pre-commit envs if hooks act weird\npre-commit clean\n\n# Confirm keyring backend\nuv run python -c \"import keyring; k=keyring.get_keyring(); print(k.__class__.__module__+'.'+k.__class__.__name__)\"\n</code></pre>"},{"location":"dev/command-reference/#11-handy-one-liners","title":"11. Handy One-liners","text":"<pre><code># Show masked usernames for all personas\nuv run adif-mcp persona list --verbose\n</code></pre>"},{"location":"dev/command-reference/#12-narrow-pytest","title":"12. Narrow PyTest","text":"<ul> <li>Run then open last failing traceback interactively <pre><code>uv run pytest -k probe -q -x\n</code></pre></li> </ul>"},{"location":"dev/command-reference/#13-suggested-aliases-optional","title":"13. Suggested Aliases (optional)","text":"<pre><code>alias amcp='uv run adif-mcp'\nalias ruffc='uv run ruff check .'\nalias mypyc='uv run mypy src'\nalias itg='uv run interrogate -c pyproject.toml'\n</code></pre>"},{"location":"dev/command-reference/#14-makefile-targets","title":"14. Makefile Targets","text":"<p>The Makefile provides shortcuts for iterative testing, linting, and packaging. Run <code>make help</code> to see the full list (excerpt below):</p> <p>NOTE: Note: All commands use <code>uv</code> consistently, respect strict lint/type/docstring/test gates, and follow the OS-agnostic/secret-safe practices defined in this project.</p> <pre><code>Developer Commands\n--------------------------------------------------------------------------------------------------------\nadd-dev                Add a dev dep (usage: make add-dev DEP=pytest)\nadd                    Add a runtime dep (usage: make add DEP=requests)\nbootstrap              Ensure dev tools (ruff/mypy/pytest/interrogate) are installed\ncheck-all              Ruff + mypy + verbose docstrings + manifest validation\ncheck-version          Ensure VERSION and/or SPEC match pyproject.toml (use VERSION=... SPEC=...)\nclean-all              Deep clean (incl. smoke venv)\nclean-pyc              Remove Python bytecode (__pycache__, *.pyc)\nclean                  Remove build artifacts (dist/build/egg-info)\ndocs-build             Build docs to ./site\ndocs-check             Verify Mermaid rendered (div.mermaid present; no code.language-mermaid left)\ndocs-dev               Generate docs/dev.md from make help\ndocs-serve             Serve MkDocs locally on http://127.0.0.1:8000/\ndocstrings             Show per-object docstring coverage with file/function lines\nformat                 Ruff format (in-place)\ngate                   CI parity gate: lint + type + tests + manifest + docstrings, keychain test\nhelp                   Show this help\ninit                   One-time bootstrap: sync deps, install hooks, run smoke-all\nlint                   Ruff lint\npre-commit-install     Install pre-commit hooks (pre-commit &amp; commit-msg)\npre-commit-run         Run hooks on all files\nprint-versions         Show versions from pyproject.toml\nprobe-all              Run both index and GET probes\nprobe-get              Run GET (network) probes for all providers\nprobe-index            Run index (no network) probes for all providers\nrelease                Tag &amp; push release [usage: make release VERSION=x.y.z SPEC=3.1.5]\nsetup-dev              Create venv, sync deps (incl. dev), install pre-commit hooks\nsmoke-all              Run smoke checks in a fresh, reproducible env\nsmoke                  quick local gate (lint+type+manifest)\nsync                   uv sync dependencies\ntest                   pytest\ntype                   mypy (src only)\nvalidate-manifest      Validate MCP manifest(s)\n</code></pre>"},{"location":"dev/dev-env-setup/","title":"Developer Environment Setup (Linux &amp; macOS)","text":"<p>This document describes how to set up a full development environment for <code>adif-mcp</code> on Linux and macOS. The project uses uv, pre-commit, and modern Python packaging. These instructions assume you are comfortable with the terminal.</p>"},{"location":"dev/dev-env-setup/#1-system-requirements","title":"1. System Requirements","text":"<ul> <li>Python: 3.11 or newer (3.13 recommended)</li> <li>uv: fast Python package manager and build tool</li> <li>git: version control</li> <li>make: for running project tasks</li> <li>pre-commit: for local checks before commit (installed via uv tools)</li> </ul>"},{"location":"dev/dev-env-setup/#linux-debianubuntu","title":"Linux (Debian/Ubuntu)","text":"<pre><code>sudo apt update\nsudo apt install -y python3 python3-venv python3-pip git make\n</code></pre>"},{"location":"dev/dev-env-setup/#macos","title":"macOS","text":"<ul> <li>Install Xcode Command Line Tools (for <code>make</code>, <code>git</code>, compilers): <pre><code>xcode-select --install\n</code></pre></li> <li>Install Homebrew (if not installed): <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre></li> <li>Ensure Python 3.11+ is installed (Homebrew or Python.org).</li> </ul>"},{"location":"dev/dev-env-setup/#2-install-uv","title":"2. Install uv","text":"<p>The project standardizes on <code>uv</code> for dependency management.</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Verify: <pre><code>uv --version\n</code></pre></p>"},{"location":"dev/dev-env-setup/#3-clone-the-repository","title":"3. Clone the Repository","text":"<pre><code>git clone https://github.com/&lt;your-org&gt;/adif-mcp.git\ncd adif-mcp\n</code></pre>"},{"location":"dev/dev-env-setup/#4-sync-dependencies","title":"4. Sync Dependencies","text":"<p>Create and sync the virtual environment:</p> <pre><code>uv sync --frozen\n</code></pre> <p>This will: - Create <code>.venv/</code> - Install runtime + dev dependencies from <code>uv.lock</code></p>"},{"location":"dev/dev-env-setup/#5-install-pre-commit-hooks","title":"5. Install pre-commit Hooks","text":"<p>Install pre-commit globally with uv:</p> <pre><code>uv tool install pre-commit\n</code></pre> <p>Register the hooks in this repo:</p> <pre><code>pre-commit install\n</code></pre> <p>You can test them manually:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"dev/dev-env-setup/#6-verify-development-setup","title":"6. Verify Development Setup","text":"<p>Run all quality gates:</p> <pre><code>make gate\n</code></pre> <p>Expected: all checks (<code>ruff</code>, <code>mypy</code>, <code>interrogate</code>, manifests) should pass.</p> <p>Run smoke tests:</p> <pre><code>make smoke-all\n</code></pre> <p>Expected: probes and CLI run without errors (Clublog probe may return HTTP 403 by design).</p>"},{"location":"dev/dev-env-setup/#7-useful-commands","title":"7. Useful Commands","text":"<ul> <li> <p>Format &amp; lint: <pre><code>uv run ruff check src --fix\nuv run ruff format src\n</code></pre></p> </li> <li> <p>Type checking: <pre><code>uv run mypy src test\n</code></pre></p> </li> <li> <p>Docstring coverage: <pre><code>uv run interrogate -v -c pyproject.toml\n</code></pre></p> </li> <li> <p>Run tests: <pre><code>uv run pytest -q\n</code></pre></p> </li> <li> <p>Validate manifests: <pre><code>make manifest\n</code></pre></p> </li> </ul>"},{"location":"dev/dev-env-setup/#8-macos-notes","title":"8. macOS Notes","text":"<ul> <li>If using Python from python.org installer, you may need: <pre><code>python3 -m ensurepip --upgrade\npython3 -m pip install --upgrade pip setuptools wheel\n</code></pre></li> <li>If keyring prompts do not appear, install <code>keyring</code> backend: <pre><code>brew install keyring\n</code></pre></li> </ul>"},{"location":"dev/dev-env-setup/#9-linux-notes","title":"9. Linux Notes","text":"<ul> <li>Some Linux distros require a keyring daemon for secrets. If unavailable, credentials will store non-secret refs only.</li> <li>Install recommended packages: <pre><code>sudo apt install gnome-keyring libsecret-1-0\n</code></pre></li> </ul>"},{"location":"dev/dev-env-setup/#10-confirm-cli-works","title":"10. Confirm CLI Works","text":"<pre><code>uv run adif-mcp --help\n</code></pre> <p>Should display the CLI help with subcommands.</p>"},{"location":"dev/dev-plan/","title":"adif-mcp: Unified Plan (Demo \u2192 Production)","text":"<p>This document consolidates the demo scope with the production-grade baseline, and clarifies where MCP manifests should live as we evolve this repo into a stable MCP server. It\u2019s the single planning page to review and iterate on.</p>"},{"location":"dev/dev-plan/#1-tldr-decisions","title":"1. TL;DR (decisions)","text":"<ul> <li>Manifests live inside the package so they ship with the server:</li> <li>Canonical: <code>src/adif_mcp/mcp/manifest.json</code></li> <li>Provider manifests (optional, only if exposing provider-scoped tools):     <code>src/adif_mcp/providers/&lt;prov&gt;/mcp/manifest.json</code></li> <li>Keep one source of truth for each manifest. Remove the legacy root <code>mcp/</code> folder after moving the manifest.</li> <li>Probes, CLI and quality gates are \u2705. Next up: add CI smoke (no network) and tag <code>v0.2.0</code>.</li> </ul>"},{"location":"dev/dev-plan/#2-current-surface-working-today","title":"2. Current Surface (working today)","text":"<ul> <li>Probes: GET-only and safe. <code>lotw</code>/<code>eqsl</code>/<code>qrz</code> \u21d2 HTTP 200; <code>clublog</code> \u21d2 expected 403 with redaction.</li> <li>CLI:</li> <li><code>adif-mcp provider index-check \u2026</code> (no network)</li> <li><code>adif-mcp provider probe \u2026</code> (network)</li> <li>Quality: <code>ruff</code>, <code>mypy --strict</code>, <code>interrogate</code> all green. <code>make gate</code> and <code>make smoke-all</code> green.</li> <li>DNS:</li> <li><code>adif-mcp.com</code> \u2192 GitHub Pages</li> <li><code>eqsl.adif-mcp.com</code> / <code>lotw.adif-mcp.com</code> \u2192 <code>adif-mcp.com</code></li> </ul>"},{"location":"dev/dev-plan/#3-manifests-placement-rules","title":"3. Manifests: Placement &amp; Rules","text":""},{"location":"dev/dev-plan/#canonical-placement","title":"Canonical Placement","text":"<ul> <li>Server manifest (single contract for the MCP server):   <pre><code>src/adif_mcp/mcp/manifest.json\n</code></pre></li> <li>Optional per-provider manifests (only if you expose provider-scoped tools or ship provider plugins):   <pre><code>src/adif_mcp/providers/eqsl/mcp/manifest.json\nsrc/adif_mcp/providers/lotw/mcp/manifest.json\n</code></pre></li> </ul>"},{"location":"dev/dev-plan/#4-validation","title":"4. Validation","text":"<p>The <code>make manifest</code> target scans all tracked <code>manifest.json</code> files and validates them. No changes needed when you move manifests under <code>src/\u2026</code>.</p>"},{"location":"dev/dev-plan/#one-source-of-truth","title":"One Source of Truth","text":"<p>Keep exactly one manifest per server or plugin. After moving the root manifest, remove the root <code>mcp/</code> to avoid drift.</p>"},{"location":"dev/dev-plan/#5-demo-scope-kept-as-plan-not-all-implemented-yet","title":"5. Demo Scope (kept as plan; not all implemented yet)","text":""},{"location":"dev/dev-plan/#what-the-demo-will-do","title":"What the demo will do","text":"<ul> <li>Fetch new eQSL entries since a date.</li> <li>Answer:   1) \u201cWhat confirmed eQSLs did I get this week?\u201d   2) \u201cHow many eQSL confirmations on 20m FT8 in August?\u201d</li> </ul>"},{"location":"dev/dev-plan/#minimal-data-surface-from-eqsl-adif","title":"Minimal Data Surface (from eQSL ADIF)","text":"<ul> <li><code>CALL</code>, <code>QSO_DATE</code>, <code>TIME_ON</code></li> <li><code>BAND</code>, <code>MODE</code>, <code>FREQ</code> (optional)</li> <li><code>EQSL_QSL_RCVD</code>, <code>EQSL_QSLRDATE</code></li> <li>Optional passthrough: <code>RST_SENT</code>, <code>RST_RCVD</code>, <code>GRIDSQUARE</code>, <code>COMMENT</code></li> </ul>"},{"location":"dev/dev-plan/#tools-demo","title":"Tools (demo)","text":"<ul> <li><code>eqsl.fetch_inbox</code></li> <li>Input: <code>{ since?: \"YYYY-MM-DD\" }</code></li> <li>Output: <code>{ records: QsoRecord[] }</code></li> <li>Behavior: real GET to <code>DownloadInBox.cfm</code> or mock file if <code>MOCK=1</code></li> <li><code>eqsl.filter_summary</code></li> <li>Input: <code>{ band?, mode?, date_from?, date_to?, confirmed_only? }</code></li> <li>Output: <pre><code>{\n  \"total\": 42,\n  \"confirmed\": 19,\n  \"by_band\": [{\"band\":\"20m\",\"count\":...}],\n  \"by_mode\": [{\"mode\":\"FT8\",\"count\":...}],\n  \"sample\": [ /* first 10 QSOs */ ]\n}\n</code></pre></li> </ul> <p>Why two tools? <code>fetch_inbox</code> centralizes I/O + normalization; <code>filter_summary</code> gives the agent fast analytics without repeated downloads.</p>"},{"location":"dev/dev-plan/#6-production-baseline-condensed","title":"6. Production Baseline (condensed)","text":""},{"location":"dev/dev-plan/#structure","title":"Structure","text":"<pre><code>adif-mcp/\n  pyproject.toml\n  src/adif_mcp/\n    mcp/manifest.json           # \u2190 canonical server manifest\n    probes/\u2026                    # safe probes (done)\n    providers/\u2026                 # adapters (done)\n    tools/\u2026                     # manifest validation, future eqsl tools\n    models.py                   # ADIF models (present; to expand)\n    # planned\n    enums.py\n    normalize.py\n  docs/\n  tests/\n</code></pre> <p>(If you later split provider plugins, each plugin repo keeps its own <code>src/adif_mcp_&lt;prov&gt;/mcp/manifest.json</code>.)</p>"},{"location":"dev/dev-plan/#types-validation","title":"Types &amp; Validation","text":"<ul> <li>Treat ADIF 3.1.x as a formal schema via Pydantic models.</li> <li>Enumerations loaded from data files, not hard-coded.</li> <li>JSON Schema exports for tool I/O.</li> <li>Normalization: uppercase CALL, YYYYMMDD date, HHMM[SS] time, MHz/frequency, watts/power.</li> </ul>"},{"location":"dev/dev-plan/#mcp-design","title":"MCP Design","text":"<ul> <li>Small, explicit tools with strict schemas and conservative defaults (limits, pagination, timeouts).</li> <li>Machine-readable errors; narrow tools over one mega-tool.</li> </ul>"},{"location":"dev/dev-plan/#testing-ci","title":"Testing &amp; CI","text":"<ul> <li>Golden fixtures for valid/invalid ADIF.</li> <li>Contract tests for MCP tools (JSON examples &amp; snapshots).</li> <li>CI: <code>uv sync --frozen</code>, <code>ruff</code>, <code>mypy --strict</code>, <code>pytest -q</code>, <code>make manifest</code>.</li> </ul>"},{"location":"dev/dev-plan/#security-ops","title":"Security &amp; Ops","text":"<ul> <li>Secrets via env/keyring; never log secrets.</li> <li>Later: API fa\u00e7ade with OAuth2/API keys; strict request bodies (Pydantic + size caps).</li> </ul>"},{"location":"dev/dev-plan/#7-immediate-actions-manifests-doc-consolidation","title":"7. Immediate Actions (manifests + doc consolidation)","text":"<p>Move the server manifest into the package: <pre><code>mkdir -p src/adif_mcp/mcp\ngit mv mcp/manifest.json src/adif_mcp/mcp/manifest.json\n</code></pre></p> <p>Docs: Add a pointer in <code>docs/mcp/manifest.md</code> that the canonical manifest now lives under <code>src/adif_mcp/mcp/manifest.json</code>. The existing <code>make manifest</code> target validates all tracked manifests.</p> <p>Keep this plan checked in as <code>docs/dev/plan.md</code> so there\u2019s one planning page.</p>"},{"location":"dev/dev-plan/#8-roadmap-near-term","title":"8. Roadmap (near-term)","text":"<p>CI smoke: run <code>make probe-index</code> (no network) in CI; skip network probes by default. Version &amp; tag: bump to <code>0.2.0</code>, update <code>CHANGELOG.md</code>, tag <code>v0.2.0</code>. Demo tools: implement <code>eqsl.fetch_inbox</code> + <code>eqsl.filter_summary</code> with mock fallback; add examples in manifest. Docs: <code>docs/integrations/eqsl/index.md</code> quickstart (mock + real creds). Models: expand ADIF models/enums + normalization helpers.</p>"},{"location":"dev/dev-plan/#acceptance-checks-every-merge","title":"Acceptance Checks (every merge)","text":"<ul> <li><code>make gate</code> \u2705</li> <li><code>make smoke-all</code> \u2705</li> <li><code>make manifest</code> \u2705</li> <li>Probes: <code>make probe-all</code> \u2705</li> </ul>"},{"location":"dev/git-commits/","title":"Commit Message Guidelines","text":"<p>We follow the Conventional Commits standard for commit messages. This makes it easier to understand project history and automatically generate changelogs.</p>"},{"location":"dev/git-commits/#format","title":"Format","text":"<ul> <li>type \u2192 what kind of change this is.</li> <li>scope (optional) \u2192 area of the codebase (e.g., <code>ui</code>, <code>ingest</code>, <code>tools</code>, <code>docs</code>).</li> <li>summary \u2192 concise description (imperative, no period).</li> </ul>"},{"location":"dev/git-commits/#common-types","title":"Common Types","text":"<ul> <li>feat \u2192 new feature   example: <code>feat(ui): add reciprocal heard analysis panel</code></li> <li>fix \u2192 bug fix   example: <code>fix(ingest): correct band_code mapping for MF range</code></li> <li>docs \u2192 documentation only   example: <code>docs(schema): add canonical WSPR spots schema doc</code></li> <li>style \u2192 formatting, whitespace, linter (no logic change)</li> <li>refactor \u2192 code restructuring without behavior change</li> <li>perf \u2192 performance improvement</li> <li>test \u2192 add or update tests</li> <li>build \u2192 build system or dependency changes</li> <li>ci \u2192 CI/CD workflows or pipelines</li> <li>chore \u2192 maintenance tasks, version bumps, release prep   example: <code>chore(release): cut v0.3.6 tag</code></li> <li>revert \u2192 undo a previous commit</li> </ul>"},{"location":"dev/git-commits/#examples","title":"Examples","text":"<ul> <li><code>feat(tools): add verify --strict and --explain options</code></li> <li><code>fix(ui): handle missing rx_version gracefully</code></li> <li><code>docs: update roadmap for v0.4.0 planning</code></li> <li><code>chore(release): prepare v0.3.6</code></li> </ul> <p>\ud83d\udca1 Tip: Keep summaries short (\u226472 chars). Add details in a commit body if needed.</p> <p>This ensures the package builds, installs, ingests, and launches the UI end-to-end.</p>"},{"location":"dev/probes/","title":"Provider Probes","text":"<p>Provider probes are sanity checks only. They confirm that credentials for a persona can be transported to the provider and accepted, without ingesting any real log data.</p>"},{"location":"dev/probes/#what-they-do","title":"What They Do","text":"<ul> <li>Index probes (<code>provider index-check</code>):</li> <li>No network calls.</li> <li>Verify that the persona has a username + secret for a provider.</li> <li> <p>Exit code <code>0</code> if present, <code>5</code> otherwise.</p> </li> <li> <p>GET probes (<code>provider probe</code>):</p> </li> <li>Safe HTTP GET requests to provider endpoints.</li> <li>Endpoints chosen to return small bodies or explicit auth errors.</li> <li>Never POST, never upload logs, never fetch large data.</li> </ul>"},{"location":"dev/probes/#credential-resolution","title":"Credential Resolution","text":"<p>All credentials are resolved via:</p> <ul> <li><code>PersonaManager</code> \u2192 reads non-secret refs from the persona index (<code>personas.json</code>).</li> <li><code>keyring</code> \u2192 retrieves the associated secret for the persona/provider.</li> </ul> <p>If either is missing, <code>PersonaManager.require()</code> raises a typed error.</p>"},{"location":"dev/probes/#usage-examples","title":"Usage Examples","text":"<pre><code># Index probes (no network)\nuv run adif-mcp provider index-check --provider eqsl    --persona MyEQSL\nuv run adif-mcp provider index-check --provider lotw    --persona MyLOTW\nuv run adif-mcp provider index-check --provider qrz     --persona MyQRZ\nuv run adif-mcp provider index-check --provider clublog --persona MyCLUBLOG\n\n# GET probes (network)\nuv run adif-mcp provider probe --provider eqsl    --persona MyEQSL    --timeout 30\nuv run adif-mcp provider probe --provider lotw    --persona MyLOTW    --timeout 30\nuv run adif-mcp provider probe --provider qrz     --persona MyQRZ     --timeout 30\nuv run adif-mcp provider probe --provider clublog --persona MyCLUBLOG --timeout 30\n</code></pre> <p>Sample Output <pre><code>[OK] lotw GET /lotwuser/lotwreport.adi?login=k***t&amp;password=&lt;redacted&gt;&amp;qso_qslsince=2025-09-03 http=200 bytes=6284\n[error] clublog GET /logsearchjson.php?call=G7VJR&amp;log=G3TXF&amp;year=2099&amp;api=&lt;redacted&gt; net=HTTPError: HTTP Error 403: Forbidden\n</code></pre></p> Code Meaning 0 Success / credentials valid. 3 Non-200 HTTP status. 4 Network error (timeout, SSL, DNS, etc.). 5 Persona/provider credential missing. 2 Usage error (bad args, JSON parse, etc.)."},{"location":"dev/probes/#safety","title":"Safety","text":"<ul> <li>Redaction: all query parameters like password, api, token are replaced with  in output. <li>Logging: only minimal endpoint path + query (with redactions) is printed.</li> <li>No secrets: usernames masked (k***t), secrets never printed.</li> <li>Verbose mode (--verbose): prints response body if &lt;512 bytes, with inline redaction.</li>"},{"location":"dev/provider-schemas/","title":"Provider Schemas &amp; Usage (how the JSON fits together)","text":"<p>This project keeps provider capabilities as data so code stays small and safe. Three pieces matter:</p> <ul> <li>Provider schemas \u2014 the minimal field sets we rely on per service src/adif_mcp/resources/providers/*.json</li> <li>Usage map \u2014 which tools/features consume which fields src/adif_mcp/resources/mapping/usage.json</li> <li>Loader helpers \u2014 a tiny API to read those files at runtime adif_mcp.resources module</li> </ul>"},{"location":"dev/provider-schemas/#why-schemas-as-json","title":"Why Schemas as JSON?","text":"<ul> <li>Keep network code narrow: only fetch what we need.</li> <li>Make it easy to add/adjust providers without touching Python.</li> <li>Enable docs/tests to reason about support (e.g., \u201cQSO lacks RST fields\u201d).</li> </ul> <p>Example: resources/providers/eqsl.json <pre><code>{\n  \"name\": \"eQSL\",\n  \"fields\": [\n    \"station_call\",\n    \"call\",\n    \"qso_date\",\n    \"time_on\",\n    \"band\",\n    \"mode\",\n    \"rst_sent\",\n    \"rst_rcvd\",\n    \"gridsquare\",\n    \"my_gridsquare\",\n    \"freq\"\n  ]\n}\n</code></pre></p>"},{"location":"dev/provider-schemas/#conventions","title":"Conventions","text":"<ul> <li>name: display label used in docs/UI.</li> <li>fields: the normalized ADIF-ish keys our parser/normalizer expects.</li> </ul> <p>Other providers are similar (LoTW, QRZ, Club Log). QRZ currently omits RST fields intentionally.</p>"},{"location":"dev/provider-schemas/#usage-map-what-consumes-what","title":"Usage map (what consumes what)","text":"<p>resources/mapping/usage.json binds features/tools to fields so both docs and code can ask, \u201cDo we have enough data to answer this?\u201d For example (simplified): <pre><code>{\n  \"tools\": {\n    \"eqsl.fetch_inbox\": [\"call\", \"qso_date\", \"time_on\", \"band\", \"mode\", \"freq\", \"eqsl_qsl_rcvd\", \"eqsl_qslrdate\"],\n    \"eqsl.filter_summary\": [\"band\", \"mode\", \"qso_date\"]\n  }\n}\n</code></pre></p> <p>This lets CI or a future \u201ccapabilities\u201d command flag gaps early.</p>"},{"location":"dev/provider-schemas/#examples","title":"Examples","text":"<p>List what we ship:</p> <pre><code>uv run python -c \"from adif_mcp.resources import list_providers; print(list_providers())\"\n</code></pre> <p>Check fields for a provider: <pre><code>uv run python - &lt;&lt;'PY'\nfrom adif_mcp.resources import load_provider\nprint(load_provider(\"eqsl\")[\"fields\"])\nPY\n</code></pre></p> <p>Confirm a tool\u2019s needs are covered by a provider: <pre><code>uv run python - &lt;&lt;'PY'\nfrom adif_mcp.resources import load_provider, get_usage_map\nprov = load_provider(\"qrz\")\nneed = set(get_usage_map()[\"tools\"][\"eqsl.filter_summary\"])\nhave = set(prov[\"fields\"])\nmissing = need - have\nprint(\"Missing:\", sorted(missing))\nPY\n</code></pre></p>"},{"location":"dev/provider-schemas/#adding-a-new-provider-checklist","title":"Adding a new provider (checklist)","text":"<ol> <li>Create src/adif_mcp/resources/providers/.json with name + fields. <li>If any tools rely on it, update resources/mapping/usage.json.</li> <li>Add a probe adapter (read-only GET) under src/adif_mcp/providers/adapters.py.</li> <li>Ensure redaction/masking rules apply to any auth materials.</li> <li>Tests:</li> <li>Unit: load_provider(\"\") returns fields. <li>Optional: \u201cwire\u201d probe behind a local env flag (no CI network).</li>"},{"location":"dev/provider-schemas/#ci-packaging-notes","title":"CI &amp; Packaging notes","text":"<ul> <li>Resources are included via tool.hatch.build.targets.wheel.packages &amp; tool.hatch.build.include.</li> <li>validate-manifest (CLI) uses the packaged manifest by default; keep it under src/adif_mcp/mcp/manifest.json.</li> <li>A simple resource smoke test exists in test/test_resources.py.</li> </ul>"},{"location":"dev/provider-schemas/#future-extensions-nice-to-have","title":"Future extensions (nice to have)","text":"<ul> <li>adif_mcp.resources.capabilities(provider) \u2192 synthesize what queries are answerable.</li> <li>Versioned provider files (e.g., providers/eqsl@2025-09.json + alias) when APIs change.</li> <li>A CLI command adif-mcp providers show  to dump fields &amp; sample coverage"},{"location":"integrations/overview/","title":"Integration Overview","text":"<p>Holding Page</p>"},{"location":"integrations/eqsl/","title":"eQSL API (MCP Tools)","text":"<ul> <li>Purpose: confirmations, awards tracking, uploads/queries</li> <li>Auth: eQSL credential handling (never exposed to the agent)</li> <li> <p>Safety: tool-scoped permissions + audit</p> </li> <li> <p><code>eqsl.upload(adif_batch)</code></p> </li> <li><code>eqsl.status(callsign, since)</code></li> <li><code>eqsl.confirmations(query)</code></li> </ul>"},{"location":"integrations/lotw/","title":"LoTW API (MCP Tools)","text":"<ul> <li>Purpose: confirmations, awards tracking, uploads/queries</li> <li>Auth: LoTW credential handling (never exposed to the agent)</li> <li> <p>Safety: tool-scoped permissions + audit</p> </li> <li> <p><code>lotw.upload(adif_batch)</code></p> </li> <li><code>lotw.status(callsign, since)</code></li> <li><code>lotw.confirmations(query)</code></li> </ul>"},{"location":"mcp/manifest/","title":"Manifest &amp; Types","text":"<ul> <li>The manifest declares available tools and their JSON schemas</li> <li>Types mirror ADIF field semantics (dates, callsigns, enums)</li> <li>Tools are minimal, composable, and verified by the MCP runtime</li> </ul>"},{"location":"mcp/overview/","title":"MCP Overview","text":"<p>Holding page.</p>"},{"location":"mcp/tools/","title":"Tools (API Surface)","text":"<p>Core examples (subject to change): - <code>adif.validate(record)</code> \u2192 returns normalized/validated record - <code>adif.transform(record, mapping)</code> \u2192 map vendor\u2192ADIF fields - <code>adif.summary(range)</code> \u2192 counts, date span, by-band/mode</p>"},{"location":"spec/spec/","title":"ADIF-MCP Specification","text":"<p>Temporary file.</p>"},{"location":"userguide/awards/","title":"Award Query Workflow Examples","text":"<p>Amateur Radio operators don\u2019t just make QSOs \u2014 they track and confirm them to pursue awards, challenges, and special programs. These awards provide goals, recognition, and a sense of achievement that keeps operating fun, motivating and educational.</p> <p>ADIF-MCP provides a foundation to query logbooks in ways that directly support award tracking. Whether you\u2019re chasing DXCC, WAS, or a niche program like SOTA or 30m Digital Group, the same core QSO data (callsign, band, mode, date, confirmation) can be filtered and summarized to answer questions like:</p> <ul> <li>\u201cWhich DXCC entities have I confirmed on 20m CW?\u201d</li> <li>\u201cHow many US States do I still need on FT8?\u201d</li> <li>\u201cAre my SOTA activations properly logged and confirmed?\u201d</li> </ul> <p>This section introduces the major award sponsors and the types of queries that matter for each. While each sponsor has its own rules and requirements, all of them build on the same ADIF fields \u2014 making MCP an ideal bridge between your logbook and the awards you care about.</p> <p>IMPORTANT - ADIF-MCP does not try to \u201cown\u201d awards. Instead, it provides a safe, typed backbone to query QSO data in ways that award sponsors already define. MCP aligns to the ADIF 3.1.5 spec, including the official <code>SponsoredAward</code> enumeration.</p>"},{"location":"userguide/awards/#core-sponsors-in-adif","title":"Core Sponsors in ADIF","text":"<p>This matrix captures who sponsors what and how MCP can expose it to operators through Integrations. As we all kknow, this is just a \"small\" sampling of whats available.</p> Sponsor Focus Notes ARRL LoTW, DXCC, WAS, VUCC, Triple Play, Challenge Premier award sponsor; strict QSO matching, digital signing via LoTW CQ Magazine WPX, WAZ, WW Contest Awards Contest-centric; CQ World Wide DX Contest is globally recognized DARC (Germany) DLD (German Districts), WAE (Worked All Europe) Strong EU/region-based award programs eQSL eDX100, eWAS, eCanada, etc. Looser confirmation rules; parallel awards to ARRL/CQ RSGB (UK) Islands on the Air (IOTA) Geographic/island award system, now standalone but ADIF-aligned Other Programs SOTA, POTA, County Hunters, 30MDG, etc. May not appear in ADIF\u2019s enumeration, but use ADIF fields"},{"location":"userguide/awards/#how-mcp-tracks-coverage","title":"How MCP Tracks Coverage","text":"<ol> <li>Spec Layer</li> <li>ADIF defines the field names (<code>call</code>, <code>dxcc</code>, <code>state</code>, <code>cqz</code>, <code>iota_ref</code>, etc.) and sponsor enumerations.</li> <li> <p>MCP maps these to canonical <code>QsoRecord</code> fields.</p> </li> <li> <p>Provider Layer</p> </li> <li>LoTW, eQSL, QRZ, Club Log expose subsets of ADIF fields.</li> <li> <p>MCP normalizes them to a common schema.</p> </li> <li> <p>Persona Layer</p> </li> <li>Operators (DXers, Contesters, SOTA/POTA activators, casual loggers) query their logs in plain language.</li> <li>MCP ensures those queries resolve only against valid fields/sponsors.</li> </ol>"},{"location":"userguide/awards/#persona-award-field-mapping-examples","title":"Persona \u2192 Award \u2192 Field Mapping (Examples)","text":"Persona Typical Award Goal Key ADIF Fields Example Query DXer DXCC (ARRL), WAZ (CQ) <code>dxcc</code>, <code>cqz</code>, <code>band</code>, <code>mode</code> \u201cHow many DXCC entities confirmed on 20m FT8?\u201d Contester CQ WPX, CQ WW <code>call</code>, <code>prefix</code>, <code>contest_id</code> \u201cShow my confirmed prefixes from last WPX contest\u201d State Chaser WAS (ARRL/eQSL) <code>state</code>, <code>band</code>, <code>mode</code> \u201cWhich states do I still need on CW?\u201d SOTA Activator/Hunter SOTA (community) <code>my_sota_ref</code>, <code>sota_ref</code> \u201cList my 2024 SOTA activations by summit code\u201d POTA Enthusiast POTA (community) <code>my_sig</code>, <code>sig_info</code> \u201cWhich parks have I activated this year?\u201d County Hunter MARAC / USA-CA <code>cnty</code> \u201cWhich counties do I still need on 40m?\u201d"},{"location":"userguide/awards/#coverage-percentage-concept","title":"Coverage Percentage (Concept)","text":"<ul> <li>Denominator = All ADIF fields relevant to awards (from catalog).</li> <li>Numerator = Fields MCP supports via QsoRecord + Provider Integrations.</li> <li>Output = Coverage % (per provider, per sponsor, per persona).</li> </ul> <p>This gives a simple way to say: - \u201cMCP covers 85% of ARRL award fields\u201d - \u201cMCP covers 60% of CQ contest awards\u201d - \u201cMCP covers 95% of SOTA/POTA fields used in the wild\u201d</p>"},{"location":"userguide/awards/#notes","title":"Notes","text":"<p>This list is not exhaustive \u2014 new awards, challenges, and operating programs emerge all the time. ADIF-MCP\u2019s role is not to enforce award rules or certify results, but to provide the reliable data plumbing needed for award-tracking tools, logbook providers, and operators to build upon.</p> <p>By keeping the MCP layer focused on safe, typed access to QSO data, it remains flexible enough to support both long-standing awards like DXCC and emerging community programs yet to be defined.</p> <p>\ud83d\udd11 Takeaway: MCP doesn\u2019t replace LoTW, eQSL, or award programs. Instead, it gives operators visibility and accessibility into their award progress, across sponsors, without them needing to export, filter, or code.</p>"},{"location":"userguide/persona-management/","title":"Personas &amp; Credentials","text":"<p>A persona is simply a way to represent an operator\u2019s on-air identity. Most hams use one primary callsign, but many also have contest calls, special-event calls, or past vanity calls that are still linked to their logging accounts. A persona lets you keep these identities separate, with optional start and end dates, so your log queries and confirmations always line up with the right callsign history.</p> <p>A keyring is your operating system\u2019s built-in secure storage for secrets like passwords or tokens. Instead of saving provider passwords in plain text, ADIF-MCP only saves the non-sensitive reference in its config file, while the actual secret is handed off to the system keyring. That means credentials are encrypted and protected the same way your browser or email client secures saved logins.</p> <p>Personas let you manage multiple operator identities (callsigns and their date ranges) and connect each one to provider credentials (LoTW, eQSL, QRZ, Club Log). This solves real-world cases like: - Primary call (no dates) - Temporary/special-event/contest calls (date-bounded) - Old calls merged into LoTW/eQSL - Multiple accounts per provider</p> <p>Personas JSON files store <code>non-secret</code> metadata on disk; secrets (passwords/tokens) are saved in your OS keyring.</p>"},{"location":"userguide/persona-management/#where-data-lives","title":"Where Data Lives","text":"<p>Index JSON (non-secret):</p> <pre><code>~/.config/adif-mcp/personas.json (default)\n\n# This psth is configrable via the project\u2019s pyproject.toml\n\n[tool.adif]\npersonas_index = \"path/to/personas.json\"\n</code></pre> <p>Provider Access Credentials ( secrets ) for LoTW, eQSL, Clublog, etc</p> <ul> <li>Secrets (passwords/tokens) are stored in the system keyring under:<ul> <li>service: adif-mcp</li> <li>key: {persona}:{provider}:{username}</li> </ul> </li> </ul> <p>If keyring isn\u2019t available, the CLI will still save the non-secret reference and tell you the secret was not stored.</p>"},{"location":"userguide/persona-management/#persona-quick-start","title":"Persona Quick Start","text":"<p>Create a primary persona and a date-bounded special-event persona, then attach credentials:</p> <pre><code># 1) Fresh list (may show \"No personas configured.\" on first run)\nuv run adif-mcp persona list\n\n# 2) Primary persona (no dates)\nuv run adif-mcp persona add --name Primary --callsign KI7MT\n\n# 3) Special-event / contest persona (date-bounded)\nuv run adif-mcp persona add \\\n  --name ContestW7A \\\n  --callsign W7A \\\n  --start 2025-03-01 \\\n  --end   2025-03-31\n\n# 4) Attach provider credentials (prompts for password; stores in keyring)\nuv run adif-mcp persona set-credential \\\n  --persona Primary \\\n  --provider lotw \\\n  --username ki7mt\n\nuv run adif-mcp persona set-credential \\\n  --persona ContestW7A \\\n  --provider lotw \\\n  --username w7a_lotw\n\n# 5) Inspect\nuv run adif-mcp persona list\nuv run adif-mcp persona show Primary\nuv run adif-mcp persona show --by callsign W7A\n</code></pre>"},{"location":"userguide/persona-management/#commands","title":"Commands","text":"<p>List - Shows each persona, callsign, date span, and which providers have credentials references. <pre><code>uv run adif-mcp persona list\n</code></pre></p> <p>Add / Update - Re-using the same --name updates the persona (callsign/dates). <pre><code>uv run adif-mcp persona add \\\n  --name &lt;PersonaName&gt; \\\n --callsign &lt;CALL&gt; \\\n [--start YYYY-MM-DD] \\\n [--end   YYYY-MM-DD]\n</code></pre></p> <p>Show <pre><code># By persona name (default)\nuv run adif-mcp persona show &lt;PersonaName&gt;\n\n# By callsign (disambiguates multiple personas that share a call)\nuv run adif-mcp persona show --by callsign &lt;CALL&gt;\n</code></pre></p> <p>Set credential (non-secret ref + secret in keyring) <pre><code>uv run adif-mcp persona set-credential \\\n  --persona &lt;PersonaName&gt; \\\n  --provider {lotw|eqsl|qrz|clublog} \\\n  --username &lt;account_username&gt;\n# Prompts for password/token securely\n</code></pre></p> <p>Remove <pre><code># Remove a single persona\nuv run adif-mcp persona remove &lt;PersonaName&gt;\n\n# Remove ALL personas (destructive; index only\u2014does not purge keyring)\nuv run adif-mcp persona remove-all\n</code></pre></p> <p>JSON on disk (reference)</p> <p>Your personas.json - Passwords/tokens are not stored here\u2014only usernames/refs.</p> <pre><code>{\n  \"personas\": {\n    \"Primary\": {\n      \"name\": \"Primary\",\n      \"callsign\": \"KI7MT\",\n      \"start\": null,\n      \"end\": null,\n      \"providers\": {\n        \"lotw\": { \"username\": \"ki7mt\" }\n      }\n    },\n    \"ContestW7A\": {\n      \"name\": \"ContestW7A\",\n      \"callsign\": \"W7A\",\n      \"start\": \"2025-03-01\",\n      \"end\": \"2025-03-31\",\n      \"providers\": {\n        \"lotw\": { \"username\": \"w7a_lotw\" }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"userguide/persona-management/#how-mcp-will-pick-a-persona-design-intent","title":"How MCP will pick a persona (design intent)","text":"<p>When you or an agent asks a log question, the eventual selection logic can: 1. Filter personas by callsign (if specified), otherwise consider all. 2. Prefer personas whose date range covers the QSO dates being queried. 3. Use the provider that\u2019s requested (or the best available for the query). 4. Fall back sensibly (e.g., no date filters \u2192 show all matching personas).</p> <p>This keeps special-event accounts separate until you intentionally merge them at the provider (e.g., LoTW/eQSL), while still letting you query broadly when you want.</p> <p>Troubleshooting - \u201cNo personas configured.\u201d</p> <p>Create one:</p> <pre><code>uv run adif-mcp persona add --name Primary --callsign &lt;CALL&gt;\n</code></pre> <ul> <li> <p>\u201cSecret was NOT stored.\u201d Your environment likely lacks a keyring backend. Install one (e.g., keyring + OS backend) and re-run persona set-credential. Non-secrets were saved; only the secret failed.</p> </li> <li> <p>Wrong date format Use ISO dates: YYYY-MM-DD.</p> </li> <li> <p>Multiple personas share a callsign Use persona show --by callsign  to inspect each; the UI will show their date spans."},{"location":"userguide/persona-management/#security-notes","title":"Security notes","text":"<ul> <li>Credentials are stored via the OS keyring whenever possible.</li> <li>You can safely commit personas.json if you wish (it contains no secrets), though it usually lives in your home config directory.</li> <li>If you rotate provider passwords, simply re-run persona set-credential for the affected persona/provider.</li> </ul>"}]}